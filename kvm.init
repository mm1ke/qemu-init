#!/sbin/runscript

# Filename: kvm.init
# Autor: Michael Mair-Keimberger (m DOT mairkeimberger AT gmail DOT com)
# Date: 13.08.2009

# Copyright (C) 2011  Michael Mair-Keimberger
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

# Discription:
# start/stop script for qemu guests

extra_commands="tapdel info"

description="Start Qemu guests"
description_save="Saves the changes within a guest to the harddisk"
description_tapdel="Deletes unused tap devices (like from a crashed guest)"
description_info="Show information about a running vm"

# programms
SLEEP="/usr/bin/sleep"
RM="/bin/rm"
PS="/bin/ps"
BRCTL="/sbin/brctl"
IP="/sbin/ip"
NC="/usr/bin/nc"
LS="/bin/ls"
WC="/bin/wc"
HEAD="/bin/head"
EGREP="/bin/egrep"
NETSTAT="/bin/netstat"
CUT="/bin/cut"
MKDIR="/bin/mkdir"

# PID dir
PID_DIR="/var/run/kvm"
# TMP dir
TMP_DIR="/var/tmp"
# max supported vms
MAX_VMS=30

# true/false
DEBUG=false

VM_NAME=${RC_SVCNAME#*.}
#
# depend()
# custom depends
#
depend(){
  need net
}

#
# scan_running_vm()
# checks other vms
#
scan_running_vm(){
  shopt -s nullglob
  local running_vm
  local running_vm_pid
  for running_vm in ${PID_DIR}/*.pid; do
    running_vm_pid=`<${running_vm}`
    if ( `${PS} -o "command=" ${running_vm_pid} | ${EGREP} "$1" > /dev/null 2>&1` ); then
      match_vm=`echo ${running_vm%.pid}`
      return 1
    fi
  done
  shopt -u nullglob
}

#
# tapdel()
# removes unused tap devices
#
tapdel(){
  local active_qtap
  # BRDEV must be set in kvm.$vmname
  if [ -z "${BRDEV}" ]; then
    ewarn "No BRDEV is set in /etc/conf.d/kvm.${VM_NAME}"
  else
    for active_qtap in `${BRCTL} show|${EGREP} qtap`; do
      if scan_running_vm "ifname=${active_qtap}"; then
	stop_id=${active_qtap:4}
	stop_tap_device
      fi
    done
  fi
}

#
# save()
# save changes within a guest
#
save(){
  ewarn "Command is disabled right now"
  #echo "commit all" | ${NC} --unix -q1 ${PID_DIR}/${VM_NAME}.sock > /dev/null 2>&1

  # link to the bugreport:
  # https://bugs.launchpad.net/qemu/+bug/1067517
  # last test:
  # app-emulation/qemu-1.2.2-r2 - dont work

}

#
# info()
# get information about running vms
#
info(){

  # there are two possibilities how to run this command:
  # first: calling kvm.init with the vm-name (/etc/init.d/kvm.winxp info)
  # 	which would show information only about the vm "winxp"
  # secondly: calling kvm.init directly (/etc/init.d/kvm.init info)
  # 	this however is not yet implemented. (see todo)
  # 	my plan is that if calling kvm.init directly, the script should output
  #	(if possibly in a nice form) information about ALL running vm's.

  # TODO: implement kvm.init info
  if [ "$VM_NAME" == "init" ]; then
    ewarn "not yet implemented"
  else
    # default settings
    local address_port="NONE"
    local qtap="NONE"
    
    # get the information
    if [ -e ${PID_DIR}/${VM_NAME}.pid ]; then
      local pid=`<${PID_DIR}/${VM_NAME}.pid`
      local uptime=`${PS} -o "etime=" ${pid}`
      local starttime=`${PS} -o "lstart=" ${pid}`
      if ( ${VM_HAVE_REOMTE_ACCESS} ); then
	# echo ${address_port#*:} # to get the address:port
	if [ "${VM_REMOTE_ACCESS}" == "spice" ]; then
	  local address_port="`echo "info spice" \
	    | ${NC} --unix -q1 ${PID_DIR}/${VM_NAME}.sock 2>&1 \
	    | ${EGREP} address`"
	elif [ "${VM_REMOTE_ACCESS}" == "vnc" ]; then
	  local address_port="`echo "info vnc" \
	    | ${NC} --unix -q1 ${PID_DIR}/${VM_NAME}.sock  2>&1 \
	    | ${EGREP} address`"
	else
	  ewarn "${VM_REMOTE_ACCESS} not valid"
	fi
      fi
      
      if ! [ "${VM_NET_TYP}" == "none" ]; then
	if [ "${VM_NET_TYP}" == "tap" ]; then
	  local qtap_dev="`echo "info network" \
	    | ${NC} --unix -q1 ${PID_DIR}/${VM_NAME}.sock 2>&1 \
	    | ${EGREP} ${VM_NAME} \
	    | ${CUT} -d ',' -f 2 \
	    | ${CUT} -d '=' -f 2`"
	fi
	if [ -z "${VM_MAC_ADDRESS}" ]; then
	  # echo ${mac_addr##*=}
	  local mac_addr="`echo "info network" \
	    | ${NC} --unix -q1 ${PID_DIR}/${VM_NAME}.sock 2>&1 \
	    | ${EGREP} macaddr`"
	else
	  local mac_addr="${VM_MAC_ADDRESS}"
	fi
      fi
    fi
    
    # it seems that einfo cannot handle variable subtitutions
    # thus output the information with einfon and echo
    einfo "Information about: ${VM_NAME}"
    if ( ${VM_SNAPSHOTMODE} ); then
      einfo " ** VM is running in SNAPSHOT mode! **"
    fi
    echo
    einfo " VM started at: ${starttime}"
    einfo " Uptime: ${uptime}"
    einfo " PID: ${pid}"
    echo
    einfo " Remote Access via: ${VM_REMOTE_ACCESS}"
    einfon " Ip/Port: "
    echo ${address_port#*:}
    echo
    einfo " Network Typ: ${VM_NET_TYP}"
    einfo " qdap-device: ${qtap_dev}"
    einfon " MAC-Address: "
    echo ${mac_addr##*=}
    
  fi
}

#
# cfgcheck()
# make some configuration checks
#
cfgcheck(){

# basic tests/settings
  [ -d ${PID_DIR} ] || ${MKDIR} ${PID_DIR}
  [ -d ${TMP_DIR} ] || TMP_DIR="/var/tmp"
  
  if ! [ `${EGREP} -i "^${VM_USER}" /etc/passwd` ]; then
    eerror "User \"${VM_USER}\" not found in /etc/passwd."
    return 1
  fi

  if [ -n "${VM_KERNEL}" ] && [ -n "${VM_INITRD}" ]; then
    VM_BOOT_DEV=""
  else
    VM_KERNEL=""
  fi

  # arch spezific configuration
  case ${VM_ARCH} in
    arm)
      # arm has only smc91c111 - see qemu-system-arm -net nic,model=?
      VM_NET_DRV="smc91c111"
      ;;
    mips)
      # mips only supports up to 256mb ram
      if [ ${VM_MEMORY} -gt 256 ]; then
	VM_MEMORY=256
	ewarn " ** MIPS only supports up to 256MB ram"
      fi
      ;;
    esac
  
  # remote access checks
  if ( ${VM_HAVE_REOMTE_ACCESS} ); then
    # set listening ip
    if [ -z "${VM_REMOTE_ACCESS_LISTEN_IP}" ]; then
      VM_REMOTE_ACCESS_LISTEN_IP="`${IP} address show ${BRDEV} \
	| ${EGREP} -o '[[:digit:]]{1,3}\.[[:digit:]]{1,3}\.[[:digit:]]{1,3}\.[[:digit:]]{1,3}'\
	| ${HEAD} -n1`"
    fi
    # set port
    # i don't use scan_running_vm here because other programms could use those ports too...
    # have to check with netstat if a port is free
    if [ -z "${VM_REMOTE_ACCESS_PORT}" ]; then
      local port_nr=0
      while $(${NETSTAT} -nat | ${EGREP} "${VM_REMOTE_ACCESS_LISTEN_IP}:580${port_nr}[^0-9]" >/dev/null ); do
	  let "port_nr += 1"
      done
      VM_REMOTE_ACCESS_PORT="580${port_nr}"
    # check port if it was manuel set
    elif $(${NETSTAT} -nat | ${EGREP} "${VM_REMOTE_ACCESS_LISTEN_IP}:${VM_REMOTE_ACCESS_PORT}[^0-9]" >/dev/null); then
      eerror "Port is already in use. Please choose an different one in /etc/conf.d/kvm.${VM_NAME}"
      return 1
    fi    
  else
    ewarn " Remote access disabled"
    VM_DISPLAY=""
  fi

  # cdrom checks
  if ! [ -z "${VM_CDROM}" ]; then
    if ! [ -e "${VM_CDROM}" ]; then
      eerror "Image dosn't exist. Please check your config (/etc/conf.d/kvm.${VM_NAME})"
      return 1
    fi
  fi

  # image checks/default settings
  if ( ${VM_HAVE_HARDDISK} ); then
    if [ -z "${VM_IMAGE}" ]; then
      eerror "No vm-image set. Please check your config (/etc/conf.d/kvm.${VM_NAME})"
      return 1
    fi

    if [ -d "${VM_IMAGE}" ]; then
      if [ -e "${VM_IMAGE}/${VM_NAME}" ]; then
	VM_IMAGE="${VM_IMAGE}/${VM_NAME}"
      elif [ `${LS} ${VM_IMAGE}${VM_NAME}[.]* | ${WC} -l` -gt 1 ]; then
	  eerror "More than one possible guest vm images found. Please check your config (/etc/conf.d/kvm.${VM_NAME})"
	  return 1
      else
	VM_IMAGE=`${LS} ${VM_IMAGE}/${VM_NAME}[.]*`
	ewarn " VM-Image set to ${VM_IMAGE}"
      fi
    elif ! [ -e "${VM_IMAGE}" ]; then
      eerror "VM-Image not found. Please check your config (/etc/conf.d/kvm.${VM_NAME})"
      return 1
    fi
    # check if image is already running
    if ! scan_running_vm "${VM_IMAGE}"; then
      eerror "This vm-image is already started by \"/etc/init.d/kvm.${match_vm##*/}\"!"
      return 1
    fi
    # set default settings for hd if nothing is set
    [ -z "${VM_IMG_CACHE}" ] && VM_IMG_CACHE="none"
    [ -z "${VM_IMG_IF}" ] && VM_IMG_IF="ide"
    [ -z "${VM_IMG_AIO}" ] && VM_IMG_AIO="threads"
  fi

  # network checks/default settings
  if [ -z "${VM_NET_TYP}" ]; then
    VM_NET_TYP="none"
  else
    # set default network driver
    [ -z "${VM_NET_DRV}" ] && VM_NET_DRV="rtl8139"
    # check for mac address
    if ! [ -z "${VM_MAC_ADDRESS}" ]; then
      if ! scan_running_vm "${VM_MAC_ADDRESS}"; then
	eerror "MAC-address already used by \"/etc/init.d/kvm.${match_vm##*/}\"!"
	return 1
      fi
    else
      # set random mac address
      VM_MAC_ADDRESS=`printf 'DE:AD:CA:5E:%02X:%02X\n' $((RANDOM%256)) $((RANDOM%256))`
      ewarn " ** RANDOM MAC ADDRESS! Address will be lost on shutdown! **"
    fi

    case ${VM_NET_TYP} in
      tap)
	if [ -n "${BRDEV}" ]; then
	  if ! ( ${IP} link show ${BRDEV} > /dev/null 2>&1 ); then
	    eerror "${BRDEV} dosen't exist. Please check your config (/etc/conf.d/kvm.${VM_NAME})"
	    return 1
	  fi
	else
	  eerror "You need a bridge device! Please check your config (/etc/conf.d/kvm.${VM_NAME})"
	  return 1
	fi
	# get the guest_nummber for qtap...
	start_id=0;
	while ( ${BRCTL} show | ${EGREP} qtap${start_id} >/dev/null 2>&1 ); do
	  let "start_id += 1"
	done
	# check for max_vms
	if [ ${start_id} -ge ${MAX_VMS} ]; then
	  eerror "Maximum number of vm's reached. Please increase the MAX_VMS variable."
	  return 1
	fi
	;;
      user|none)
	;;
      *)
	ewarn "** Unknow Network Typ. Network will be disabled"
	VM_NET_TYP="none"
	;;
    esac
  fi
  
  if ( ${VM_SNAPSHOTMODE} ); then
    ewarn " ** SNAPSHOT MODE! Changes in the guest system won't be saved! **"
  fi
}

#
# myconfig()
# function to generate the start config
#
myconfig(){

  # basic config
  myconfig="-name ${VM_NAME} \
  -runas ${VM_USER} \
  -monitor unix:${PID_DIR}/${VM_NAME}.sock,server,nowait \
  -pidfile ${PID_DIR}/${VM_NAME}.pid "
  
  # if nothing is set, qemu defaults to 128mb memory and smp=1
  [ -z "${VM_MEMORY}" ] || myconfig="${myconfig} -m ${VM_MEMORY}"
  [ -z "${VM_SMP}" ] || myconfig="${myconfig} -smp ${VM_SMP}"
  [ -z "${VM_MACHINE}" ] || myconfig="${myconfig} -machine ${VM_MACHINE}"

  if [ -n "${VM_KERNEL}" ]; then
    myconfig="${myconfig} -kernel ${VM_KERNEL} -initrd ${VM_INITRD}"
    [ -z "${VM_APPEND}" ] || myconfig="${myconfig} -append \"${VM_APPEND}\""
  fi

  # daemonize true/false
  ( ${VM_DAEMONIZE} ) && myconfig="${myconfig} -daemonize"
  # snapshotmode on/off
  ( ${VM_SNAPSHOTMODE} ) && myconfig="${myconfig} -snapshot"
  # spice virtual serial port (copy/paste)
  ( ${VM_HAVE_VIRTSERIAL} ) && myconfig="${myconfig} -device virtio-serial \
  -chardev spicevmc,id=vdagent,name=vdagent \
  -device virtserialport,chardev=vdagent,name=com.redhat.spice.0"
  # qemu guest agent (qga)
  ( ${VM_HAVE_QGA} ) && myconfig="${myconfig} -device virtio-serial \
  -chardev socket,path=${PID_DIR}/${VM_NAME}-qga.sock,server,nowait,id=${VM_NAME}-qga \
  -device virtserialport,chardev=${VM_NAME}-qga,name=org.qemu.qga.0"
  # enable/disable harddisk
  ( ${VM_HAVE_HARDDISK} ) && myconfig="${myconfig} \
  -drive file=${VM_IMAGE},if=${VM_IMG_IF},cache=${VM_IMG_CACHE},aio=${VM_IMG_AIO}"

  # network settings
  case ${VM_NET_TYP} in
    tap)
      myconfig="${myconfig} \
      -netdev type=tap,id="${VM_NAME}_${start_id}",vhost=on,ifname=qtap${start_id},script=no,downscript=no \
      -device ${VM_NET_DRV},netdev="${VM_NAME}_${start_id}",mac=${VM_MAC_ADDRESS}"
      ;;
    user)
      myconfig="${myconfig} \
      -netdev type=user,id=${VM_NAME}_${start_id} \
      -device ${VM_NET_DRV},netdev="${VM_NAME}_${start_id}",mac=${VM_MAC_ADDRESS}"
      ;;
    none)
      myconfig="${myconfig} -net none"
      ;;
  esac
  
  if ( ${VM_HAVE_REOMTE_ACCESS} ); then
    case ${VM_REMOTE_ACCESS} in
      spice|SPICE)
	VM_DISPLAY="qxl"
	! [ -z "${VM_REMOTE_ACCESS_PW}" ] || VM_REMOTE_ACCESS_PW="\"\",disable-ticketing"
	myconfig="${myconfig} -spice port=${VM_REMOTE_ACCESS_PORT},addr=${VM_REMOTE_ACCESS_LISTEN_IP},password=${VM_REMOTE_ACCESS_PW}"
	;;
      vnc|VNC)
	myconfig="${myconfig} -vnc ${VM_REMOTE_ACCESS_LISTEN_IP}:${VM_REMOTE_ACCESS_PORT}"
	;;
      *)
	ewarn " Unknow option. Remote access will be disabled"
	myconfig="${myconfig} -nographic"
	;;
    esac
  else
    myconfig="${myconfig} -nographic"
  fi

  [ -z "${VM_LC}" ] || myconfig="${myconfig} -k ${VM_LC}"
  [ -z "${VM_CPU}" ] || myconfig="${myconfig} -cpu ${VM_CPU}"
  [ -z "${VM_USB}" ] || myconfig="${myconfig} -usb ${VM_USB}"
  [ -z "${VM_DISPLAY}" ] || myconfig="${myconfig} -vga ${VM_DISPLAY}"
  [ -z "${VM_AUDIO}" ] || myconfig="${myconfig} -soundhw ${VM_AUDIO}"
  [ -z "${VM_OTHERS}" ] || myconfig="${myconfig} ${VM_OTHERS}"
  [ -z "${VM_CDROM}" ] || myconfig="${myconfig} -cdrom ${VM_CDROM}"

  if ! [ -z ${VM_BOOT_DEV} ]; then
    case ${VM_BOOT_DEV} in 
      floppy|a)
	myconfig="${myconfig} -boot a"
	;;
      harddisk|c)
	myconfig="${myconfig} -boot c"
	;;
      cdrom|d)
	myconfig="${myconfig} -boot d"
	;;
      network|n)
	myconfig="${myconfig} -boot n"
	;;
      *)
	ewarn " Unknow boot option. Won't set any boot options"
	;;
    esac
  fi
}

#
# start_tap_device()
# function to find out the tap id
#
start_tap_device(){
  einfo "Setting up the tap interface: qtap${start_id}"
  ${IP} tuntap add dev qtap${start_id} mode tap user ${VM_USER} || return 1

  einfo " Linking the bridge interface with qtap${start_id}"
  ${BRCTL} addif ${BRDEV} qtap${start_id} || return 1

  einfo " Bring qtap${start_id} interface up"
  ${IP} link set dev qtap${start_id} up promisc on || return 1
}

#
# stop_tap_device()
# function to find the vm's tap device and stop it
#
stop_tap_device(){
  einfo "Bring qtap${stop_id} interface down"
  ${IP} link set dev qtap${stop_id} down
  eend $? "Failed to bring qtap${stop_id} down"

  einfo " Unlinking the bridge interface with qtap${stop_id}"
  ${BRCTL} delif ${BRDEV} qtap${stop_id}
  eend $? "Failed to unlink the bridge interface to qtap${stop_id}"

  ${SLEEP} 2
  einfo " Removing the tap interface: qtap${stop_id}"
  ${IP} tuntap del qtap${stop_id} mode tap
}

#
# start()
# starts the vm
#
start(){
  local qemu_bin

  # Test if requested arch is available in qemu
  # defaulting to system arch
  [[ ! -n ${VM_ARCH} ]] && VM_ARCH=$(uname -m)
  if $(type -P qemu-system-${VM_ARCH} &>/dev/null); then
    qemu_bin=$(type -P qemu-system-${VM_ARCH})
  else
    eerror "No support of ${VM_ARCH} in your qemu installation"
    exit 1
  fi

  cfgcheck || return 1
  myconfig || return 1
  [ ${VM_NET_TYP} == "tap" ] && start_tap_device

  ebegin "Start ${VM_NAME}"

  (${DEBUG}) && echo -e "* Qemu settings:\n\t \
    qemu-bin: ${qemu_bin}\n\t \
    tmpdir: ${TMP_DIR}\n\t \
    user: ${VM_USER}\n\t \
    memory: ${VM_MEMORY} \n\t \
    image: ${VM_IMAGE}\n\t \
    kernel: ${VM_KERNEL}\n\t \
    kernel cmd: ${VM_APPEND}\n\t \
    initrd: ${VM_INITRD}\n\t \
    network-typ: ${VM_NET_TYP}\n\t \
    bridge device: ${BRDEV}\n\t \
    qtap-interface: qtap${start_id}\n\t \
    remote-access-port: ${VM_REMOTE_ACCESS_PORT}\n\t \
    remote-access-typ: ${VM_REMOTE_ACCESS}\n\t \
    boot from: ${VM_BOOT_DEV}\n\t \
    boot media: ${VM_CDROM}\n\t \
    full config: ${myconfig}"

  # Start the Virtual Machine
  TMPDIR="${TMP_DIR}" ${qemu_bin} ${myconfig} >/dev/null 2>&1

  # remove tap devices if the guest system couldn't be started
  if (( $? )); then
    if [ ${VM_NET_TYP} == "tap" ]; then
      eerror "Failed to start ${VM_NAME}, shuting down qtap${start_id}"
      stop_id=${start_id}
      stop_tap_device || return 1
    fi
    return 1
  fi

  eend $?
}

#
# stop()
# stopping the vm
#
stop(){

  # set default kill wait to 80 seconds
  if [ -z "${VM_KILL_WAIT}" ]; then
    VM_KILL_WAIT=80
  fi

  local KVM_PID=`<${PID_DIR}/${VM_NAME}.pid`

  if ( ${PS} -p ${KVM_PID} --no-heading > /dev/null 2>&1 ); then
  
    # set VM_NET_TYP to none if the var is empty, otherwise the below test would fail if the var would be empty
    [ -z "${VM_NET_TYP}" ] && VM_NET_TYP="none"
    # find the next free qtap interface
    if [ ${VM_NET_TYP} == "tap" ]; then
      stop_id=0
      while ! ( ${PS} -o "command=" ${KVM_PID} | ${EGREP} qtap${stop_id} >/dev/null ); do
	let "stop_id += 1"
	# try qtap0 to qtap${MAX_VMS} for possible ${MAX_VMS} virtual maschines
	if [ ${stop_id} -eq ${MAX_VMS} ]; then
	  ewarn "Couldn't find a qtap device. Please run \"/etc/init.d/kvm.init tapdel\""
	  stop_id=""
	  break
	fi
      done
    fi

    ebegin "Stopping ${VM_NAME}"
    # sending via nc (netcat) the shutdown command
    echo "system_powerdown" | ${NC} --unix -q1 ${PID_DIR}/${VM_NAME}.sock > /dev/null 2>&1
    # waiting for system to shutdown
    
    einfon "Waiting \"$((VM_KILL_WAIT))\" seconds for ${VM_NAME} to shutdown ."
    for timer in `eval echo {1..$((VM_KILL_WAIT/2))}`; do
      if [ -z "`${PS} -p ${KVM_PID} --no-heading`" ]; then
	echo
	einfo " Stopped ${VM_NAME}"
	break
      # if the system couldn't be shutdown
      elif [ ${timer} -eq "$((VM_KILL_WAIT/2))" ]; then
	echo
	eerror "Shuddown of ${VM_NAME} failed, will kill guest"
	# kill qemu
	kill -9 ${KVM_PID} > /dev/null 2>&1
	${SLEEP} 2
	ewarn " Killed ${VM_NAME}"
	break
      fi
      ${SLEEP} 2
      echo -n "."
    done

    # stop qtap device
    [ -z ${stop_id} ] || stop_tap_device

    # remove remaining files
    ${RM} -rf ${PID_DIR}/${VM_NAME}.pid
    ${RM} -rf ${PID_DIR}/${VM_NAME}.sock
    ${RM} -rf ${PID_DIR}/${VM_NAME}-qga.sock

  else
    ewarn "Couldn't find the process for ${VM_NAME}, guest might already down."
    eend 0
  fi

  eend $?
}
